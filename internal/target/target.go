// Package target handles information about directories and files to be generated.
package target

import (
	"path/filepath"
	"runtime"
	"strings"

	"github.com/nao1215/ubume/internal/gotool"
)

// Dirs returns the directory to be created.
// name   : Project name
// libP   : Whether to create library project
// noRoot : Whether to create the project root directory (project name directory)
func Dirs(name string, lib, cli, noRoot bool) []string {
	dirs := []string{}
	if noRoot {
		dirs = append(dirs, filepath.Join(".github", "workflows"))
	} else {
		dirs = append(dirs, filepath.Join(name, ".github", "workflows"))
	}

	if lib {
		if !noRoot {
			dirs = append(dirs, name)
		}
	} else if cli {
		if noRoot {
			dirs = append(dirs, "cmd")
			dirs = append(dirs, filepath.Join("internal", "cmdinfo"))
		} else {
			dirs = append(dirs, filepath.Join(name, "cmd"))
			dirs = append(dirs, filepath.Join(name, "internal", "cmdinfo"))
		}
	} else {
		if noRoot {
			dirs = append(dirs, filepath.Join("cmd", name))
		} else {
			dirs = append(dirs, filepath.Join(name, "cmd", name))
		}
	}
	return dirs
}

// Files returns the directory to be created.
func Files(name, importPath string, lib, cli, noRoot bool) map[string]string {
	files := map[string]string{}

	if lib {
		path, code := librarySourceCodeFile(name, noRoot)
		files[path] = code
	} else if cli {
		path, code := cliMainSourceCodeFile(name, importPath, noRoot)
		files[path] = code
	} else {
		path, code := applicationMainSourceCodeFile(name, noRoot)
		files[path] = code
	}

	if !cli {
		path, code := mainTestFile(name, lib, noRoot)
		files[path] = code
	}

	if cli {
		path, code := rootFile(name, noRoot)
		files[path] = code
		path, code = versionFile(name, noRoot)
		files[path] = code
		path, code = cmdInfoFile(name, noRoot)
		files[path] = code
	}

	path, code := docGoFile(name, lib, cli, noRoot)
	files[path] = code

	path, code = makefile(name, lib, cli, noRoot)
	files[path] = code

	path, code = changelogFile(name, noRoot)
	files[path] = code

	if !lib {
		path, code = githubBuildYml(name, noRoot)
		files[path] = code
		path, code = githubRelease(name, noRoot)
		files[path] = code
		path, code = goreleaser(name, noRoot, cli)
		files[path] = code
	}
	path, code = githubUnitTestYml(name, noRoot)
	files[path] = code

	path, code = githubReviewDog(name, noRoot)
	files[path] = code

	return files
}

func applicationMainSourceCodeFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", name, "main.go")
	} else {
		path = filepath.Join(name, "cmd", name, "main.go")
	}

	code := `package main

import "fmt"

func main() {
	fmt.Println(HelloWorld())
}

func HelloWorld() string {
	return "Hello, World"
}
`
	return path, code
}

func cliMainSourceCodeFile(name, importPath string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = "main.go"
	} else {
		path = filepath.Join(name, "main.go")
	}

	code := `package main

import "XXX_IMPORT_PATH_XXX"

func main() {
	cmd.Execute()
}
`
	return path, strings.ReplaceAll(code, "XXX_IMPORT_PATH_XXX", filepath.Join(importPath, "cmd"))
}

func librarySourceCodeFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(name + ".go")
	} else {
		path = filepath.Join(name, name+".go")
	}

	code := `package XXX_PKG_XXX

func HelloWorld() string {
	return "Hello, World"
}
`
	return path, strings.ReplaceAll(code, "XXX_PKG_XXX", name)
}

func mainTestFile(name string, libProject, noRoot bool) (string, string) {
	code := `package XXX_PKG_XXX

import "testing"
	
func TestHelloWorld(t *testing.T) {
	if HelloWorld() != "Hello, World" {
		t.Errorf("HelloWorlf = %s, want \"Hello, World\"", HelloWorld())
	}
}
	`
	var path string
	if libProject {
		if noRoot {
			path = filepath.Join(name + "_test.go")
		} else {
			path = filepath.Join(name, name+"_test.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", name)
	} else {
		if noRoot {
			path = filepath.Join("cmd", name, "main_test.go")
		} else {
			path = filepath.Join(name, "cmd", name, "main_test.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", "main")
	}
	return path, code
}

func docGoFile(name string, libProject, cli, noRoot bool) (string, string) {
	code := `// This package is generated by ubume command.
//
// If you publish this module on GitHub etc., please write down the 
// application description in this file. When your package is published
// to "https://pkg.go.dev/", the contents of doc.go will be automatically
// listed as an overview on the pkg.go.dev.
package XXX_PKG_XXX
`
	var path string
	if libProject {
		if noRoot {
			path = filepath.Join("doc.go")
		} else {
			path = filepath.Join(name, "doc.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", name)
	} else if cli {
		if noRoot {
			path = "doc.go"
		} else {
			path = filepath.Join(name, "doc.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", "main")
	} else {
		if noRoot {
			path = filepath.Join("cmd", name, "doc.go")
		} else {
			path = filepath.Join(name, "cmd", name, "doc.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", "main")
	}
	return path, code
}

func makefile(name string, libProject, cli, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = "Makefile"
	} else {
		path = filepath.Join(name, "Makefile")
	}

	code := `.PHONY: build test clean vet fmt chkfmt

APP         = XXX_APP_XXX
GO          = go
GO_BUILD    = $(GO) build
GO_FORMAT   = $(GO) fmt
GOFMT       = gofmt
GO_LIST     = $(GO) list
GO_TEST     = $(GO) test -v
GO_TOOL     = $(GO) tool
GO_VET      = $(GO) vet
GO_DEP      = $(GO) mod
GOOS        = XXX_OS_XXX
GOARCH      = XXX_ARCH_XXX
GO_PKGROOT  = ./...
GO_PACKAGES = $(shell $(GO_LIST) $(GO_PKGROOT))

XXX_ONLY_APP_XXX

clean: ## Clean project
	-rm -rf $(APP) cover.out cover.html

test: ## Start test
	env GOOS=$(GOOS) $(GO_TEST) -cover $(GO_PKGROOT) -coverprofile=cover.out
	$(GO_TOOL) cover -html=cover.out -o cover.html

vet: ## Start go vet
	$(GO_VET) $(GO_PACKAGES)

fmt: ## Format go source code 
	$(GO_FORMAT) $(GO_PKGROOT)

.DEFAULT_GOAL := help
help:  
	@grep -E '^[0-9a-zA-Z_-]+[[:blank:]]*:.*?## .*$$' $(MAKEFILE_LIST) | sort \
	| awk 'BEGIN {FS = ":.*?## "}; {printf "\033[1;32m%-15s\033[0m %s\n", $$1, $$2}'
`

	strOnlyApp := `build:  ## Build binary
	env GO111MODULE=on GOOS=$(GOOS) GOARCH=$(GOARCH) $(GO_BUILD) $(GO_LDFLAGS) -o $(APP) XXX_CODE_XXX`

	if libProject {
		code = strings.Replace(code, "XXX_ONLY_APP_XXX", "", 1)
	} else if cli {
		code = strings.Replace(code, "XXX_ONLY_APP_XXX", strOnlyApp, 1)
		code = strings.Replace(code, "XXX_CODE_XXX", filepath.Join("main.go"), 1)
	} else {
		code = strings.Replace(code, "XXX_ONLY_APP_XXX", strOnlyApp, 1)
		code = strings.Replace(code, "XXX_CODE_XXX", filepath.Join("cmd", name, "main.go"), 1)
	}
	code = strings.Replace(code, "XXX_APP_XXX", name, 1)
	code = strings.Replace(code, "XXX_OS_XXX", runtime.GOOS, 1)
	code = strings.Replace(code, "XXX_ARCH_XXX", runtime.GOARCH, 1)
	return path, code
}

func changelogFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = "Changelog.md"
	} else {
		path = filepath.Join(name, "Changelog.md")
	}

	data := `# Changelog
All notable changes to this project will be documented in this file.  
The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).   
This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
`
	return path, data
}

func githubBuildYml(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".github", "workflows", "build.yml")
	} else {
		path = filepath.Join(name, ".github", "workflows", "build.yml")
	}
	data := `name: Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: "XXX_VER_XXX"

    - name: Build
      run: make build
`
	data = strings.Replace(data, "XXX_VER_XXX", gotool.Version(), 1)
	return path, data
}

func githubUnitTestYml(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".github", "workflows", "unit_test.yml")
	} else {
		path = filepath.Join(name, ".github", "workflows", "unit_test.yml")
	}
	data := `name: UnitTest

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: "XXX_VER_XXX"

    - name: UnitTest
      run: make test
`
	data = strings.Replace(data, "XXX_VER_XXX", gotool.Version(), 1)
	return path, data
}

func githubReviewDog(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".github", "workflows", "reviewdog.yml")
	} else {
		path = filepath.Join(name, ".github", "workflows", "reviewdog.yml")
	}
	data := `name: reviewdog
on: [pull_request]

jobs:
  golangci-lint:
    name: golangci-lint
    runs-on: ubuntu-latest
    steps:
      - name: Check out code into the Go module directory
        uses: actions/checkout@v2
        with:
          persist-credentials: false
      - name: golangci-lint
        uses: reviewdog/action-golangci-lint@v2
        with:
          reporter: github-pr-review
          level: warning

  misspell:
    name: misspell
    runs-on: ubuntu-latest
    steps:
      - name: Check out code into the Go module directory
        uses: actions/checkout@v2
        with:
          persist-credentials: false
      - name: misspell
        uses: reviewdog/action-misspell@v1
        with:
          reporter: github-pr-review
          level: warning
          locale: "US"

  actionlint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: reviewdog/action-actionlint@v1
        with:
          reporter: github-pr-review
          level: warning
`
	return path, data
}

func githubRelease(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".github", "workflows", "release.yml")
	} else {
		path = filepath.Join(name, ".github", "workflows", "release.yml")
	}
	data := `name: Release

on:
  push:
    tags:
      - "v*"

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          - name: Setup Go
            uses: actions/setup-go@v2
            with:
              go-version: "XXX_VER_XXX"
          - name: Run GoReleaser
            uses: goreleaser/goreleaser-action@v2
            with:
              version: latest
              args: release --rm-dist
            env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
`
	data = strings.Replace(data, "XXX_VER_XXX", gotool.Version(), 1)
	return path, data
}

func goreleaser(name string, noRoot, cli bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".goreleaser.yml")
	} else {
		path = filepath.Join(name, ".goreleaser.yml")
	}
	data := `project_name: XXX_APP_NAME_XXX
env:
  - GO111MODULE=on
before:
  hooks:
    - go mod tidy
    - go generate ./...
builds:
  - main: XXX_BUILD_TARGET_XXX
    ldflags:
      - -s -w
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - windows
      - darwin
    archives:
      - name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
        replacements:
          darwin: Darwin
          linux: Linux
          windows: Windows
          386: i386
          amd64: x86_64
        format_overrides:
          - goos: windows
            format: zip
    checksum:
      name_template: "checksums.txt"
    snapshot:
      name_template: "{{ incpatch .Version }}-next"
    changelog:
      sort: asc
      filters:
        exclude:
          - "^docs:"
          - "^test:"	
`
	data = strings.Replace(data, "XXX_APP_NAME_XXX", name, 1)
	if cli {
		data = strings.Replace(data, "XXX_BUILD_TARGET_XXX", "./cmd/"+name, 1)
	} else {
		data = strings.Replace(data, "XXX_BUILD_TARGET_XXX", ".", 1)
	}
	return path, data
}

func rootFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", "root.go")
	} else {
		path = filepath.Join(name, "cmd", "root.go")
	}
	data := `package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use: "XXX_CMD_XXX",
}

func exitError(msg interface{}) {
	fmt.Fprintln(os.Stderr, msg)
	os.Exit(1)
}

func Execute() {
	rootCmd.Run = func(cmd *cobra.Command, args []string) {
		_ = rootCmd.Help()
	}

	if err := rootCmd.Execute(); err != nil {
		exitError(err)
	}
}
`
	data = strings.Replace(data, "XXX_CMD_XXX", name, 1)
	return path, data
}

func versionFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", "version.go")
	} else {
		path = filepath.Join(name, "cmd", "version.go")
	}
	data := `package cmd

import (
	"fmt"

	"XXX_NAME_XXX/internal/cmdinfo"
	"github.com/spf13/cobra"
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Show " + cmdinfo.Name() + " command version information",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(cmdinfo.Version())
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
}
`
	data = strings.Replace(data, "XXX_NAME_XXX", name, 1)
	return path, data
}

func cmdInfoFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("internal", "cmdinfo", "cmdinfo.go")
	} else {
		path = filepath.Join(name, "internal", "cmdinfo", "cmdinfo.go")
	}
	data := `package cmdinfo

import (
	"fmt"
)

const (
	name    = "XXX_NAME_XXX"
	version = "0.0.1"
)

// Version return command version.
func Version() string {
	return fmt.Sprintf("%s version %s (under Apache License version 2.0)",
		Name(), version)
}

// Name return command name.
func Name() string {
	return name
}
`
	data = strings.Replace(data, "XXX_NAME_XXX", name, 1)
	return path, data
}
