// Package target handles information about directories and files to be generated.
package target

import (
	"path/filepath"
	"runtime"
	"strings"

	"github.com/nao1215/ubume/internal/gotool"
)

// Dirs returns the directory to be created.
// name   : Project name
// libP   : Whether to create library project
// noRoot : Whether to create the project root directory (project name directory)
func Dirs(name string, lib, cli, noRoot bool) []string {
	dirs := []string{}
	if noRoot {
		dirs = append(dirs, filepath.Join(".github", "workflows"))
	} else {
		dirs = append(dirs, filepath.Join(name, ".github", "workflows"))
	}

	if lib {
		if !noRoot {
			dirs = append(dirs, name)
		}
	} else if cli {
		if noRoot {
			dirs = append(dirs, "cmd")
		} else {
			dirs = append(dirs, filepath.Join(name, "cmd"))
		}
	} else {
		if noRoot {
			dirs = append(dirs, filepath.Join("cmd", name))
		} else {
			dirs = append(dirs, filepath.Join(name, "cmd", name))
		}
	}
	return dirs
}

// Files returns the directory to be created.
func Files(name, importPath string, lib, cli, noRoot bool) map[string]string {
	files := map[string]string{}

	if lib {
		path, code := librarySourceCodeFile(name, noRoot)
		files[path] = code
	} else if cli {
		path, code := cliMainSourceCodeFile(name, importPath, noRoot)
		files[path] = code
	} else {
		path, code := applicationMainSourceCodeFile(name, noRoot)
		files[path] = code
	}

	if !cli {
		path, code := mainTestFile(name, lib, noRoot)
		files[path] = code
	}

	if cli {
		path, code := rootFile(name, noRoot)
		files[path] = code
		path, code = versionFile(name, noRoot)
		files[path] = code
		path, code = versionTestFile(name, noRoot)
		files[path] = code
	}

	path, code := docGoFile(name, lib, cli, noRoot)
	files[path] = code

	path, code = makefile(name, lib, cli, noRoot)
	files[path] = code

	path, code = changelogFile(name, noRoot)
	files[path] = code

	if !lib {
		path, code = githubBuildYml(name, noRoot)
		files[path] = code
	}
	path, code = githubUnitTestYml(name, noRoot)
	files[path] = code

	return files
}

func applicationMainSourceCodeFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", name, "main.go")
	} else {
		path = filepath.Join(name, "cmd", name, "main.go")
	}

	code := `package main

import "fmt"

func main() {
	fmt.Println(HelloWorld())
}

func HelloWorld() string {
	return "Hello, World"
}
`
	return path, code
}

func cliMainSourceCodeFile(name, importPath string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = "main.go"
	} else {
		path = filepath.Join(name, "main.go")
	}

	code := `package main

import "XXX_IMPORT_PATH_XXX"

func main() {
	cmd.Execute()
}
`
	return path, strings.ReplaceAll(code, "XXX_IMPORT_PATH_XXX", filepath.Join(importPath, "cmd"))
}

func librarySourceCodeFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(name + ".go")
	} else {
		path = filepath.Join(name, name+".go")
	}

	code := `package XXX_PKG_XXX

func HelloWorld() string {
	return "Hello, World"
}
`
	return path, strings.ReplaceAll(code, "XXX_PKG_XXX", name)
}

func mainTestFile(name string, libProject, noRoot bool) (string, string) {
	code := `package XXX_PKG_XXX

import "testing"
	
func TestHelloWorld(t *testing.T) {
	if HelloWorld() != "Hello, World" {
		t.Errorf("HelloWorlf = %s, want \"Hello, World\"", HelloWorld())
	}
}
	`
	var path string
	if libProject {
		if noRoot {
			path = filepath.Join(name + "_test.go")
		} else {
			path = filepath.Join(name, name+"_test.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", name)
	} else {
		if noRoot {
			path = filepath.Join("cmd", name, "main_test.go")
		} else {
			path = filepath.Join(name, "cmd", name, "main_test.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", "main")
	}
	return path, code
}

func docGoFile(name string, libProject, cli, noRoot bool) (string, string) {
	code := `// This package is generated by ubume command.
//
// If you publish this module on GitHub etc., please write down the 
// application description in this file. When your package is published
// to "https://pkg.go.dev/", the contents of doc.go will be automatically
// listed as an overview on the pkg.go.dev.
package XXX_PKG_XXX
`
	var path string
	if libProject {
		if noRoot {
			path = filepath.Join("doc.go")
		} else {
			path = filepath.Join(name, "doc.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", name)
	} else if cli {
		if noRoot {
			path = "doc.go"
		} else {
			path = filepath.Join(name, "doc.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", "main")
	} else {
		if noRoot {
			path = filepath.Join("cmd", name, "doc.go")
		} else {
			path = filepath.Join(name, "cmd", name, "doc.go")
		}
		code = strings.ReplaceAll(code, "XXX_PKG_XXX", "main")
	}
	return path, code
}

func makefile(name string, libProject, cli, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = "Makefile"
	} else {
		path = filepath.Join(name, "Makefile")
	}

	code := `.PHONY: build test clean vet fmt chkfmt

APP         = XXX_APP_XXX
GO          = go
GO_BUILD    = $(GO) build
GO_FORMAT   = $(GO) fmt
GOFMT       = gofmt
GO_LIST     = $(GO) list
GO_TEST     = $(GO) test -v
GO_TOOL     = $(GO) tool
GO_VET      = $(GO) vet
GO_DEP      = $(GO) mod
GOOS        = XXX_OS_XXX
GO_PKGROOT  = ./...
GO_PACKAGES = $(shell $(GO_LIST) $(GO_PKGROOT))

XXX_ONLY_APP_XXX

test: ## Start test
	env GOOS=$(GOOS) $(GO_TEST) -cover $(GO_PKGROOT) -coverprofile=cover.out
	$(GO_TOOL) cover -html=cover.out -o cover.html

vet: ## Start go vet
	$(GO_VET) $(GO_PACKAGES)

fmt: ## Format go source code 
	$(GO_FORMAT) $(GO_PKGROOT)

.DEFAULT_GOAL := help
help:  
	@grep -E '^[0-9a-zA-Z_-]+[[:blank:]]*:.*?## .*$$' $(MAKEFILE_LIST) | sort \
	| awk 'BEGIN {FS = ":.*?## "}; {printf "\033[1;32m%-15s\033[0m %s\n", $$1, $$2}'
`

	strOnlyApp := `build:  ## Build binary
	env GO111MODULE=on GOOS=$(GOOS) $(GO_BUILD) $(GO_LDFLAGS) -o $(APP) XXX_CODE_XXX

clean: ## Clean project
	-rm -rf $(APP) cover.out cover.html
`

	if libProject {
		code = strings.Replace(code, "XXX_ONLY_APP_XXX", "", 1)
	} else if cli {
		code = strings.Replace(code, "XXX_ONLY_APP_XXX", strOnlyApp, 1)
		code = strings.Replace(code, "XXX_CODE_XXX", filepath.Join("main.go"), 1)
	} else {
		code = strings.Replace(code, "XXX_ONLY_APP_XXX", strOnlyApp, 1)
		code = strings.Replace(code, "XXX_CODE_XXX", filepath.Join("cmd", name, "main.go"), 1)
	}
	code = strings.Replace(code, "XXX_APP_XXX", name, 1)
	code = strings.Replace(code, "XXX_OS_XXX", runtime.GOOS, 1)
	return path, code
}

func changelogFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = "Changelog.md"
	} else {
		path = filepath.Join(name, "Changelog.md")
	}

	data := `# Changelog
All notable changes to this project will be documented in this file.  
The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).   
This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
`
	return path, data
}

func githubBuildYml(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".github", "workflows", "build.yml")
	} else {
		path = filepath.Join(name, ".github", "workflows", "build.yml")
	}
	data := `name: Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: XXX_VER_XXX

    - name: Build
      run: make build
`
	data = strings.Replace(data, "XXX_VER_XXX", gotool.Version(), 1)
	return path, data
}

func githubUnitTestYml(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join(".github", "workflows", "unit_test.yml")
	} else {
		path = filepath.Join(name, ".github", "workflows", "unit_test.yml")
	}
	data := `name: UnitTest

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: 1.17

    - name: UnitTest
      run: make test
`
	data = strings.Replace(data, "XXX_VER_XXX", gotool.Version(), 1)
	return path, data
}

func rootFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", "root.go")
	} else {
		path = filepath.Join(name, "cmd", "root.go")
	}
	data := `package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use: "XXX_CMD_XXX",
}

func exitError(msg interface{}) {
	fmt.Fprintln(os.Stderr, msg)
	os.Exit(1)
}

func Execute() {
	rootCmd.Run = func(cmd *cobra.Command, args []string) {
		_ = rootCmd.Help()
	}

	if err := rootCmd.Execute(); err != nil {
		exitError(err)
	}
}
`
	data = strings.Replace(data, "XXX_CMD_XXX", name, 1)
	return path, data
}

func versionFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", "version.go")
	} else {
		path = filepath.Join(name, "cmd", "version.go")
	}
	data := `package cmd

import (
	"fmt"
	"runtime"

	"github.com/spf13/cobra"
)

var (
	Revision = "dev"
	Version  = "dev"
)

func getVersion() string {
	return fmt.Sprintf("Version: %s Revision: %s OS: %sArch: %s", 
						Version, Revision, runtime.GOOS, runtime.GOARCH)
}

var versionCmd = &cobra.Command{
	Use: "version",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(getVersion())
	},
	Short: "Show version info",
}

func init() {
	rootCmd.AddCommand(versionCmd)
}
`
	return path, data
}

func versionTestFile(name string, noRoot bool) (string, string) {
	var path string
	if noRoot {
		path = filepath.Join("cmd", "version_test.go")
	} else {
		path = filepath.Join(name, "cmd", "version_test.go")
	}
	data := `package cmd

import (
	"fmt"
	"runtime"
	"testing"
)

func TestGetVersion(t *testing.T) {
	got := getVersion()
	want := fmt.Sprintf("Version: %s Revision: %s OS: %sArch: %s",
						Version, Revision, runtime.GOOS, runtime.GOARCH)

	if want != got {
		t.Fatalf("unexpected version info. want: %s, got: %s", want, got)
	}
}
`
	return path, data
}
